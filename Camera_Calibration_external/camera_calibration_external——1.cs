//
// File generated by HDevelop for HALCON/.NET (C#) Version 12.0.2
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
  public void dev_update_off ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
  public void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ContinueMessage = null, hv_Row = null;
    HTuple hv_Column = null, hv_Width = null, hv_Height = null;
    HTuple hv_Ascent = null, hv_Descent = null, hv_TextWidth = null;
    HTuple hv_TextHeight = null;
    // Initialize local and output iconic variables 
    //This procedure displays 'Press Run (F5) to continue' in the
    //lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //Color: defines the text color.
    //   If set to '' or 'auto', the currently set color is used.
    //Box: If set to 'true', the text is displayed in a box.
    //
    hv_ContinueMessage = "Press Run (F5) to continue";
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    HOperatorSet.GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", 
        out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
    disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
        (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {



      // Local iconic variables 

      // Local control variables 

      HTuple hv_M = null, hv_N = null, hv_Red = null;
      HTuple hv_Green = null, hv_Blue = null, hv_RowI1Part = null;
      HTuple hv_ColumnI1Part = null, hv_RowI2Part = null, hv_ColumnI2Part = null;
      HTuple hv_RowIWin = null, hv_ColumnIWin = null, hv_WidthWin = null;
      HTuple hv_HeightWin = null, hv_I = null, hv_RowI = new HTuple();
      HTuple hv_ColumnI = new HTuple(), hv_StringI = new HTuple();
      HTuple hv_MaxAscent = new HTuple(), hv_MaxDescent = new HTuple();
      HTuple hv_MaxWidth = new HTuple(), hv_MaxHeight = new HTuple();
      HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRowI = new HTuple();
      HTuple hv_FactorColumnI = new HTuple(), hv_UseShadow = new HTuple();
      HTuple hv_ShadowColor = new HTuple(), hv_Exception = new HTuple();
      HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
      HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
      HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
      HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
      HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
      HTuple hv_CurrentColor = new HTuple();
      HTuple   hv_Box_COPY_INP_TMP = hv_Box.Clone();
      HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
      HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
      HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
      HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

      // Initialize local and output iconic variables 
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically...
    //   - if |Row| == |Column| == 1: for each new textline
    //   = else for each text position.
    //Box: If Box[0] is set to 'true', the text is written within an orange box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow
    //       otherwise -> use given string as color string for the shadow color
    //
    //It is possible to display multiple text strings in a single call.
    //In this case, some restrictions apply:
    //- Multiple text positions can be defined by specifying a tuple
    //  with multiple Row and/or Column coordinates, i.e.:
    //  - |Row| == n, |Column| == n
    //  - |Row| == n, |Column| == 1
    //  - |Row| == 1, |Column| == n
    //- If |Row| == |Column| == 1,
    //  each element of String is display in a new textline.
    //- If multiple positions or specified, the number of Strings
    //  must match the number of positions, i.e.:
    //  - Either |String| == n (each string is displayed at the
    //                          corresponding position),
    //  - or     |String| == 1 (The string is displayed n times).
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    if ((int)(new HTuple(hv_Box_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Box_COPY_INP_TMP = "false";
    }
    //
    //
    //Check conditions
    //
    hv_M = (new HTuple(hv_Row_COPY_INP_TMP.TupleLength()))*(new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
        ));
    hv_N = new HTuple(hv_Row_COPY_INP_TMP.TupleLength());
    if ((int)((new HTuple(hv_M.TupleEqual(0))).TupleOr(new HTuple(hv_String_COPY_INP_TMP.TupleEqual(
        new HTuple())))) != 0)
    {

      return;
    }
    if ((int)(new HTuple(hv_M.TupleNotEqual(1))) != 0)
    {
      //Multiple positions
      //
      //Expand single parameters
      if ((int)(new HTuple((new HTuple(hv_Row_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_N = new HTuple(hv_Column_COPY_INP_TMP.TupleLength());
        HOperatorSet.TupleGenConst(hv_N, hv_Row_COPY_INP_TMP, out hv_Row_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_Column_COPY_INP_TMP, out hv_Column_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(new HTuple(hv_Row_COPY_INP_TMP.TupleLength())))) != 0)
      {
        throw new HalconException("Number of elements in Row and Column does not match.");
      }
      if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_String_COPY_INP_TMP, out hv_String_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(hv_N))) != 0)
      {
        throw new HalconException("Number of elements in Strings does not match number of positions.");
      }
      //
    }
    //
    //Prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_RowI1Part, out hv_ColumnI1Part, 
        out hv_RowI2Part, out hv_ColumnI2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowIWin, out hv_ColumnIWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //Loop over all positions
    HTuple end_val89 = hv_N-1;
    HTuple step_val89 = 1;
    for (hv_I=0; hv_I.Continue(end_val89, step_val89); hv_I = hv_I.TupleAdd(step_val89))
    {
      hv_RowI = hv_Row_COPY_INP_TMP.TupleSelect(hv_I);
      hv_ColumnI = hv_Column_COPY_INP_TMP.TupleSelect(hv_I);
      //Allow multiple strings for a single position.
      if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
      {
        hv_StringI = hv_String_COPY_INP_TMP.Clone();
      }
      else
      {
        //In case of multiple positions, only single strings
        //are allowed per position.
        //For line breaks, use \n in this case.
        hv_StringI = hv_String_COPY_INP_TMP.TupleSelect(hv_I);
      }
      //Default settings
      //-1 is mapped to 12.
      if ((int)(new HTuple(hv_RowI.TupleEqual(-1))) != 0)
      {
        hv_RowI = 12;
      }
      if ((int)(new HTuple(hv_ColumnI.TupleEqual(-1))) != 0)
      {
        hv_ColumnI = 12;
      }
      //
      //Split string into one string per line.
      hv_StringI = (((""+hv_StringI)+"")).TupleSplit("\n");
      //
      //Estimate extentions of text depending on font size.
      HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
          out hv_MaxWidth, out hv_MaxHeight);
      if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
      {
        hv_R1 = hv_RowI.Clone();
        hv_C1 = hv_ColumnI.Clone();
      }
      else
      {
        //Transform image to window coordinates.
        hv_FactorRowI = (1.0*hv_HeightWin)/((hv_RowI2Part-hv_RowI1Part)+1);
        hv_FactorColumnI = (1.0*hv_WidthWin)/((hv_ColumnI2Part-hv_ColumnI1Part)+1);
        hv_R1 = (((hv_RowI-hv_RowI1Part)+0.5)*hv_FactorRowI)-0.5;
        hv_C1 = (((hv_ColumnI-hv_ColumnI1Part)+0.5)*hv_FactorColumnI)-0.5;
      }
      //
      //Display text box depending on text size.
      hv_UseShadow = 1;
      hv_ShadowColor = "gray";
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
      {
        if (hv_Box_COPY_INP_TMP == null)
          hv_Box_COPY_INP_TMP = new HTuple();
        hv_Box_COPY_INP_TMP[0] = "#fce9d4";
        hv_ShadowColor = "#f28d26";
      }
      if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
        {
          //Use default ShadowColor set above
        }
        else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
            "false"))) != 0)
        {
          hv_UseShadow = 0;
        }
        else
        {
          hv_ShadowColor = hv_Box_COPY_INP_TMP.TupleSelect(1);
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                1));
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = new HTuple("Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)");
            throw new HalconException(hv_Exception);
          }
        }
      }
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
      {
        //Valid color?
        try
        {
          HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
              0));
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_Exception = new HTuple("Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)");
          throw new HalconException(hv_Exception);
        }
        //Calculate box extents
        hv_StringI = (" "+hv_StringI)+" ";
        hv_Width = new HTuple();
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index), 
              out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
          hv_Width = hv_Width.TupleConcat(hv_W);
        }
        hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_StringI.TupleLength()));
        hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
        hv_R2 = hv_R1+hv_FrameHeight;
        hv_C2 = hv_C1+hv_FrameWidth;
        //Display rectangles
        HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
        HOperatorSet.SetDraw(hv_WindowHandle, "fill");
        //Set shadow color
        HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
        if ((int)(hv_UseShadow) != 0)
        {
          HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, 
              hv_C2+1);
        }
        //Set box color
        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
        HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
        HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
      }
      //Write text.
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        //Set color
        if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
        {
          //Wiht a single text position, each text line
          //may get a different color.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        else
        {
          //With multiple text positions, each position
          //gets a single color for all text lines.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_I%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
            "auto")))) != 0)
        {
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = ((("Wrong value of control parameter Color["+(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                ))))+"] == '")+hv_CurrentColor)+"' (must be a valid color string)";
            throw new HalconException(hv_Exception);
          }
        }
        else
        {
          HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        }
        //Finally display text
        hv_RowI = hv_R1+(hv_MaxHeight*hv_Index);
        HOperatorSet.SetTposition(hv_WindowHandle, hv_RowI, hv_C1);
        HOperatorSet.WriteString(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index));
      }
    }
    //Reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_RowI1Part, hv_ColumnI1Part, hv_RowI2Part, 
        hv_ColumnI2Part);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_BufferWindowHandle = new HTuple();
        HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_Scale = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_SubFamily = new HTuple(), hv_Fonts = new HTuple();
        HTuple hv_SystemFonts = new HTuple(), hv_Guess = new HTuple();
        HTuple hv_I = new HTuple(), hv_Index = new HTuple(), hv_AllowedFontSizes = new HTuple();
        HTuple hv_Distances = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_FontSelRegexp = new HTuple(), hv_FontsCourier = new HTuple();
        HTuple   hv_Bold_COPY_INP_TMP = hv_Bold.Clone();
        HTuple   hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple   hv_Size_COPY_INP_TMP = hv_Size.Clone();
        HTuple   hv_Slant_COPY_INP_TMP = hv_Slant.Clone();

        // Initialize local and output iconic variables 
    //This procedure sets the text font of the current window with
    //the specified attributes.
    //It is assumed that following fonts are installed on the system:
    //Windows: Courier New, Arial Times New Roman
    //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
    //Linux: courier, helvetica, times
    //Because fonts are displayed smaller on Linux than on Windows,
    //a scaling factor of 1.25 is used the get comparable results.
    //For Linux, only a limited number of font sizes is supported,
    //to get comparable results, it is recommended to use one of the
    //following sizes: 9, 11, 14, 16, 20, 27
    //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
    //
    //Input parameters:
    //WindowHandle: The graphics window for which the font will be set
    //Size: The font size. If Size=-1, the default of 16 is used.
    //Bold: If set to 'true', a bold font is used
    //Slant: If set to 'true', a slanted font is used
    //
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    // dev_get_preferences(...); only in hdevelop
    // dev_set_preferences(...); only in hdevelop
    if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
    {
      hv_Size_COPY_INP_TMP = 16;
    }
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      //Set font on Windows systems
      try
      {
        //Check, if font scaling is switched on
        HOperatorSet.OpenWindow(0, 0, 256, 256, 0, "buffer", "", out hv_BufferWindowHandle);
        HOperatorSet.SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
        HOperatorSet.GetStringExtents(hv_BufferWindowHandle, "test_string", out hv_Ascent, 
            out hv_Descent, out hv_Width, out hv_Height);
        //Expected width is 110
        hv_Scale = 110.0/hv_Width;
        hv_Size_COPY_INP_TMP = ((hv_Size_COPY_INP_TMP*hv_Scale)).TupleInt();
        HOperatorSet.CloseWindow(hv_BufferWindowHandle);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
      if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
          new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Courier New";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Consolas";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Arial";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Times New Roman";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-"+hv_Font_COPY_INP_TMP)+"-")+hv_Size_COPY_INP_TMP)+"-*-")+hv_Slant_COPY_INP_TMP)+"-*-*-")+hv_Bold_COPY_INP_TMP)+"-");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
    }
    else if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Dar"))) != 0)
    {
      //Set font on Mac OS X systems. Since OS X does not have a strict naming
      //scheme for font attributes, we use tables to determine the correct font
      //name.
      hv_SubFamily = 0;
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_SubFamily = hv_SubFamily.TupleBor(1);
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_SubFamily = hv_SubFamily.TupleBor(2);
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Menlo-Regular";
        hv_Fonts[1] = "Menlo-Italic";
        hv_Fonts[2] = "Menlo-Bold";
        hv_Fonts[3] = "Menlo-BoldItalic";
      }
      else if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
          new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "CourierNewPSMT";
        hv_Fonts[1] = "CourierNewPS-ItalicMT";
        hv_Fonts[2] = "CourierNewPS-BoldMT";
        hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "ArialMT";
        hv_Fonts[1] = "Arial-ItalicMT";
        hv_Fonts[2] = "Arial-BoldMT";
        hv_Fonts[3] = "Arial-BoldItalicMT";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "TimesNewRomanPSMT";
        hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
        hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
        hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
      }
      else
      {
        //Attempt to figure out which of the fonts installed on the system
        //the user could have meant.
        HOperatorSet.QueryFont(hv_WindowHandle, out hv_SystemFonts);
        hv_Fonts = new HTuple();
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Regular");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"MT");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[0] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of slanted font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Italic");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-ItalicMT");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Oblique");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[1] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of bold font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Bold");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldMT");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[2] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of bold slanted font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldItalic");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldItalicMT");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldOblique");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[3] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
      }
      hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_SubFamily);
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, (hv_Font_COPY_INP_TMP+"-")+hv_Size_COPY_INP_TMP);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
    }
    else
    {
      //Set font for UNIX systems
      hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP*1.25;
      hv_AllowedFontSizes = new HTuple();
      hv_AllowedFontSizes[0] = 11;
      hv_AllowedFontSizes[1] = 14;
      hv_AllowedFontSizes[2] = 17;
      hv_AllowedFontSizes[3] = 20;
      hv_AllowedFontSizes[4] = 25;
      hv_AllowedFontSizes[5] = 34;
      if ((int)(new HTuple(((hv_AllowedFontSizes.TupleFind(hv_Size_COPY_INP_TMP))).TupleEqual(
          -1))) != 0)
      {
        hv_Distances = ((hv_AllowedFontSizes-hv_Size_COPY_INP_TMP)).TupleAbs();
        HOperatorSet.TupleSortIndex(hv_Distances, out hv_Indices);
        hv_Size_COPY_INP_TMP = hv_AllowedFontSizes.TupleSelect(hv_Indices.TupleSelect(
            0));
      }
      if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
          "Courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "courier";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "helvetica";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "times";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "bold";
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "medium";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("times"))) != 0)
        {
          hv_Slant_COPY_INP_TMP = "i";
        }
        else
        {
          hv_Slant_COPY_INP_TMP = "o";
        }
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = "r";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font_COPY_INP_TMP)+"-")+hv_Bold_COPY_INP_TMP)+"-")+hv_Slant_COPY_INP_TMP)+"-normal-*-")+hv_Size_COPY_INP_TMP)+"-*-*-*-*-*-*-*");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_OS.TupleSubstr(0,4))).TupleEqual("Linux"))).TupleAnd(
            new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
        {
          HOperatorSet.QueryFont(hv_WindowHandle, out hv_Fonts);
          hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold_COPY_INP_TMP)+"-")+hv_Slant_COPY_INP_TMP;
          hv_FontsCourier = ((hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp))).TupleRegexpMatch(
              hv_FontSelRegexp);
          if ((int)(new HTuple((new HTuple(hv_FontsCourier.TupleLength())).TupleEqual(
              0))) != 0)
          {
            hv_Exception = "Wrong font name";
            //throw (Exception)
          }
          else
          {
            try
            {
              HOperatorSet.SetFont(hv_WindowHandle, (((hv_FontsCourier.TupleSelect(
                  0))+"-normal-*-")+hv_Size_COPY_INP_TMP)+"-*-*-*-*-*-*-*");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException2)
            {
              HDevExpDefaultException2.ToHTuple(out hv_Exception);
              //throw (Exception)
            }
          }
        }
        //throw (Exception)
      }
    }
    // dev_set_preferences(...); only in hdevelop

    return;
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_Caltab, ho_ROI, ho_ImageReduced;
    HObject ho_Lines, ho_ContoursTrans, ho_Map, ho_ImageMapped;

    // Local control variables 

    HTuple hv_ImgPath = null, hv_WindowHandle = null;
    HTuple hv_CamParam = new HTuple(), hv_Exception = null;
    HTuple hv_CaltabName = null, hv_CalibDataID = null, hv_RCoord = null;
    HTuple hv_CCoord = null, hv_Index = null, hv_PoseForCalibrationPlate = null;
    HTuple hv_X = null, hv_Y = null, hv_Z = null, hv_FinalPose = null;
    HTuple hv_Errors = null, hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Button = new HTuple(), hv_X1 = new HTuple();
    HTuple hv_Y1 = new HTuple(), hv_ROI_X_WCS = null, hv_ROI_Y_WCS = null;
    HTuple hv_ROI_Z_WCS = null, hv_CCS_HomMat_WCS = null, hv_CCS_RectangleX = null;
    HTuple hv_CCS_RectangleY = null, hv_CCS_RectangleZ = null;
    HTuple hv_RectangleRow = null, hv_RectangleCol = null;
    HTuple hv_RowCenterROI = null, hv_ColCenterROI = null;
    HTuple hv_PhiROI = null, hv_Length1ROI = null, hv_Length2ROI = null;
    HTuple hv_MeasureHandle = null, hv_RowEdgeFirst = null;
    HTuple hv_ColumnEdgeFirst = null, hv_AmplitudeFirst = null;
    HTuple hv_RowEdgeSecond = null, hv_ColumnEdgeSecond = null;
    HTuple hv_AmplitudeSecond = null, hv_IntraDistance = null;
    HTuple hv_InterDistance = null, hv_RowPitchLine = null;
    HTuple hv_ColPitchLine = null, hv_i = null, hv_RelPose = null;
    HTuple hv_HomMat3D = null, hv_HomMat3DRel = null, hv_HomMat3DAdapted = null;
    HTuple hv_HomMat3DTranslate = null, hv_PoseAdapted = null;
    HTuple hv_YOfContour = null, hv_XOfContour = null, hv_MeterReading = null;
    HTuple hv_WidthMappedImage = null, hv_HeightMappedImage = null;
    HTuple hv_DistP0P1WCS = null, hv_DistP0P1PCS = null, hv_Scale = null;
    HTuple hv_CenterRow = null, hv_CenterColumn = null, hv_Button1 = null;
    HTuple hv_CenterX = null, hv_CenterY = null, hv_PoseNewOrigin = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Caltab);
    HOperatorSet.GenEmptyObj(out ho_ROI);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_Lines);
    HOperatorSet.GenEmptyObj(out ho_ContoursTrans);
    HOperatorSet.GenEmptyObj(out ho_Map);
    HOperatorSet.GenEmptyObj(out ho_ImageMapped);
    try
    {
      //Attention:
      //This program reads the internal camera parameters from the file
      //'camera_parameters.dat', which, e.g., could be generated by the program
      //'camera_calibration_internal.hdev'
      //
      hv_ImgPath = "3d_machine_vision/calib/";
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(0,0,652,494,0,"","",out hv_WindowHandle);
      HDevWindowStack.Push(hv_WindowHandle);
      dev_update_off();
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 1);
      }
      set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
      //Read the internal camera parameters from file
      try
      {
        HOperatorSet.ReadCamPar("camera_parameters.dat", out hv_CamParam);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //run 'camera_calibration_internal.hdev' first to generate camera
        //parameter file 'camera_parameters.dat'
        // stop(...); only in hdevelop
      }
      //
      //Determine the external camera parameters and world coodinates from image points
      //
      //The external camera parameters can be determined from an image, where the
      //calibration plate is positioned directly on the measurement plane
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, hv_ImgPath+"calib_11");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      hv_CaltabName = "caltab_30mm.descr";
      HOperatorSet.CreateCalibData("calibration_object", 1, 1, out hv_CalibDataID);
      //Here, the final camera parameters are already known and can be used instead
      //of the starting values used in the program 'camera_calibration_internal.hdev'
      HOperatorSet.SetCalibDataCamParam(hv_CalibDataID, 0, "area_scan_division", 
          hv_CamParam);
      HOperatorSet.SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CaltabName);
      HOperatorSet.FindCalibObject(ho_Image, hv_CalibDataID, 0, 0, 1, new HTuple(), 
          new HTuple());
      ho_Caltab.Dispose();
      HOperatorSet.GetCalibDataObservContours(out ho_Caltab, hv_CalibDataID, "caltab", 
          0, 0, 1);
      HOperatorSet.GetCalibDataObservPoints(hv_CalibDataID, 0, 0, 1, out hv_RCoord, 
          out hv_CCoord, out hv_Index, out hv_PoseForCalibrationPlate);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Caltab, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
      }
      HOperatorSet.DispCaltab(hv_WindowHandle, hv_CaltabName, hv_CamParam, hv_PoseForCalibrationPlate, 
          1);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
      }
      HOperatorSet.DispCircle(hv_WindowHandle, hv_RCoord, hv_CCoord, HTuple.TupleGenConst(
          new HTuple(hv_RCoord.TupleLength()),1.5));
      //caltab_points (CaltabName, X, Y, Z)
      //calibrate_cameras (CalibDataID, Error)
      //To take the thickness of the calibration plate into account, the z-value
      //of the origin given by the camera pose has to be translated by the
      //thickness of the calibration plate.
      //Deactivate the following line if you do not want to add the correction.
      HOperatorSet.SetOriginPose(hv_PoseForCalibrationPlate, 0, 0, 0.00075, out hv_PoseForCalibrationPlate);
      HOperatorSet.ClearCalibData(hv_CalibDataID);
      disp_continue_message(hv_WindowHandle, "black", "true");
      // stop(...); only in hdevelop
      //Alternatively, the external camera parameters can  be determined from
      //at least three point correspondances between the WCS and the pixel coordinate system
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, hv_ImgPath+"caliper_01");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Set the world coordinates of three points on the rule
      hv_X = new HTuple();
      hv_X[0] = 0;
      hv_X[1] = 50;
      hv_X[2] = 100;
      hv_X[3] = 80;
      hv_Y = new HTuple();
      hv_Y[0] = 5;
      hv_Y[1] = 0;
      hv_Y[2] = 5;
      hv_Y[3] = 0;
      hv_Z = new HTuple();
      hv_Z[0] = 0;
      hv_Z[1] = 0;
      hv_Z[2] = 0;
      hv_Z[3] = 0;
      //Set the respective image plane coordinates of the three points
      hv_RCoord = new HTuple();
      hv_RCoord[0] = 414;
      hv_RCoord[1] = 227;
      hv_RCoord[2] = 85;
      hv_RCoord[3] = 128;
      hv_CCoord = new HTuple();
      hv_CCoord[0] = 119;
      hv_CCoord[1] = 318;
      hv_CCoord[2] = 550;
      hv_CCoord[3] = 448;
      //
      HOperatorSet.DispCross(hv_WindowHandle, hv_RCoord, hv_CCoord, 6, 0);
      //create_pose (-50, 25, 400, 0, 0, -30, 'Rp+T', 'gba', 'point', InitialPose)
      HOperatorSet.VectorToPose(hv_X, hv_Y, hv_Z, hv_RCoord, hv_CCoord, hv_CamParam, 
          "iterative", "error", out hv_FinalPose, out hv_Errors);
      HOperatorSet.WritePose(hv_FinalPose, "pose_from_three_points.dat");
      //Now, transform a point measured interactively into the WCS
      // dev_update_window(...); only in hdevelop
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      while ((int)(1) != 0)
      {
        disp_message(hv_WindowHandle, "Measure one point: left mouse button", "window", 
            12, 12, "red", "false");
        disp_message(hv_WindowHandle, "Exit measure mode: right mouse button", "window", 
            36, 12, "red", "false");
        HOperatorSet.GetMbutton(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Button);
        if ((int)(new HTuple(hv_Button.TupleEqual(4))) != 0)
        {
          break;
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
        }
        HOperatorSet.DispCross(hv_WindowHandle, hv_Row, hv_Column, 6, 0);
        HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_FinalPose, hv_Row, hv_Column, 
            1, out hv_X1, out hv_Y1);
        disp_message(hv_WindowHandle, "X = "+hv_X1, "window", 320, 400, "red", "false");
        disp_message(hv_WindowHandle, "Y = "+hv_Y1, "window", 340, 400, "red", "false");
      }
      //Apply the measure tool and transform the resulting point coordinates
      //into the WCS
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Set the world coordinates of four points defining a ROI for the measure tool
      hv_ROI_X_WCS = new HTuple();
      hv_ROI_X_WCS[0] = -2;
      hv_ROI_X_WCS[1] = -2;
      hv_ROI_X_WCS[2] = 112;
      hv_ROI_X_WCS[3] = 112;
      hv_ROI_Y_WCS = new HTuple();
      hv_ROI_Y_WCS[0] = 0;
      hv_ROI_Y_WCS[1] = 0.5;
      hv_ROI_Y_WCS[2] = 0.5;
      hv_ROI_Y_WCS[3] = 0;
      hv_ROI_Z_WCS = new HTuple();
      hv_ROI_Z_WCS[0] = 0;
      hv_ROI_Z_WCS[1] = 0;
      hv_ROI_Z_WCS[2] = 0;
      hv_ROI_Z_WCS[3] = 0;
      //Determine the transformation matrix from the WCS into the CCS
      HOperatorSet.PoseToHomMat3d(hv_FinalPose, out hv_CCS_HomMat_WCS);
      //Transform the point coordintes into the image coordinate system
      HOperatorSet.AffineTransPoint3d(hv_CCS_HomMat_WCS, hv_ROI_X_WCS, hv_ROI_Y_WCS, 
          hv_ROI_Z_WCS, out hv_CCS_RectangleX, out hv_CCS_RectangleY, out hv_CCS_RectangleZ);
      HOperatorSet.Project3dPoint(hv_CCS_RectangleX, hv_CCS_RectangleY, hv_CCS_RectangleZ, 
          hv_CamParam, out hv_RectangleRow, out hv_RectangleCol);
      ho_ROI.Dispose();
      HOperatorSet.GenRegionPolygonFilled(out ho_ROI, hv_RectangleRow, hv_RectangleCol);
      HOperatorSet.SmallestRectangle2(ho_ROI, out hv_RowCenterROI, out hv_ColCenterROI, 
          out hv_PhiROI, out hv_Length1ROI, out hv_Length2ROI);
      //Create a measure
      HOperatorSet.GenMeasureRectangle2(hv_RowCenterROI, hv_ColCenterROI, hv_PhiROI, 
          hv_Length1ROI, hv_Length2ROI, 652, 494, "bilinear", out hv_MeasureHandle);
      HOperatorSet.MeasurePairs(ho_Image, hv_MeasureHandle, 0.4, 5, "all_strongest", 
          "all", out hv_RowEdgeFirst, out hv_ColumnEdgeFirst, out hv_AmplitudeFirst, 
          out hv_RowEdgeSecond, out hv_ColumnEdgeSecond, out hv_AmplitudeSecond, 
          out hv_IntraDistance, out hv_InterDistance);
      HOperatorSet.CloseMeasure(hv_MeasureHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      disp_message(hv_WindowHandle, "Measuring the position of the pitch lines", 
          "window", 450, 25, "red", "false");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
      }
      hv_RowPitchLine = (hv_RowEdgeFirst+hv_RowEdgeSecond)/2.0;
      hv_ColPitchLine = (hv_ColumnEdgeFirst+hv_ColumnEdgeSecond)/2.0;
      HOperatorSet.DispCross(hv_WindowHandle, hv_RowPitchLine, hv_ColPitchLine, 6, 
          0);
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_FinalPose, hv_RowPitchLine, 
          hv_ColPitchLine, 1, out hv_X1, out hv_Y1);
      for (hv_i=1; (int)hv_i<=(int)(new HTuple(hv_X1.TupleLength())); hv_i = (int)hv_i + 1)
      {
        HOperatorSet.SetTposition(hv_WindowHandle, (hv_RowEdgeFirst.TupleSelect(hv_i-1))+5, 
            (hv_ColumnEdgeFirst.TupleSelect(hv_i-1))-20);
        if ((int)(new HTuple(hv_i.TupleEqual(new HTuple(hv_X1.TupleLength())))) != 0)
        {
          HOperatorSet.SetTposition(hv_WindowHandle, hv_RowEdgeFirst.TupleSelect(
              hv_i-1), hv_ColumnEdgeFirst.TupleSelect(hv_i-2));
        }
        HOperatorSet.WriteString(hv_WindowHandle, (((hv_X1.TupleSelect(hv_i-1))).TupleString(
            ".3f"))+"mm");
      }
      disp_continue_message(hv_WindowHandle, "black", "true");
      // stop(...); only in hdevelop
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Apply a line extraction and transform the resulting XLD contours
      //into the WCS
      //Set the world coordinates of four points defining a ROI
      hv_ROI_X_WCS = new HTuple();
      hv_ROI_X_WCS[0] = 11;
      hv_ROI_X_WCS[1] = 11;
      hv_ROI_X_WCS[2] = 13;
      hv_ROI_X_WCS[3] = 13;
      hv_ROI_Y_WCS = new HTuple();
      hv_ROI_Y_WCS[0] = 4;
      hv_ROI_Y_WCS[1] = 6;
      hv_ROI_Y_WCS[2] = 6;
      hv_ROI_Y_WCS[3] = 4;
      hv_ROI_Z_WCS = new HTuple();
      hv_ROI_Z_WCS[0] = 0;
      hv_ROI_Z_WCS[1] = 0;
      hv_ROI_Z_WCS[2] = 0;
      hv_ROI_Z_WCS[3] = 0;
      //Transform the point coordinates into the image coordinate system
      HOperatorSet.AffineTransPoint3d(hv_CCS_HomMat_WCS, hv_ROI_X_WCS, hv_ROI_Y_WCS, 
          hv_ROI_Z_WCS, out hv_CCS_RectangleX, out hv_CCS_RectangleY, out hv_CCS_RectangleZ);
      HOperatorSet.Project3dPoint(hv_CCS_RectangleX, hv_CCS_RectangleY, hv_CCS_RectangleZ, 
          hv_CamParam, out hv_RectangleRow, out hv_RectangleCol);
      //Visualize the square in the original image
      HOperatorSet.DispPolygon(hv_WindowHandle, hv_RectangleRow.TupleConcat(hv_RectangleRow.TupleSelect(
          0)), hv_RectangleCol.TupleConcat(hv_RectangleCol.TupleSelect(0)));
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //create the ROI
      ho_ROI.Dispose();
      HOperatorSet.GenRegionPolygonFilled(out ho_ROI, hv_RectangleRow, hv_RectangleCol);
      ho_ImageReduced.Dispose();
      HOperatorSet.ReduceDomain(ho_Image, ho_ROI, out ho_ImageReduced);
      //Extract the lines
      ho_Lines.Dispose();
      HOperatorSet.LinesGauss(ho_ImageReduced, out ho_Lines, 1, 3, 8, "dark", "true", 
          "bar-shaped", "true");
      //Adapt the pose of the measurement plane to the tilted plane of the vernier
      hv_RelPose = new HTuple();
      hv_RelPose[0] = 0;
      hv_RelPose[1] = 3.2;
      hv_RelPose[2] = 0;
      hv_RelPose[3] = -14;
      hv_RelPose[4] = 0;
      hv_RelPose[5] = 0;
      hv_RelPose[6] = 0;
      HOperatorSet.PoseToHomMat3d(hv_FinalPose, out hv_HomMat3D);
      HOperatorSet.PoseToHomMat3d(hv_RelPose, out hv_HomMat3DRel);
      HOperatorSet.HomMat3dCompose(hv_HomMat3D, hv_HomMat3DRel, out hv_HomMat3DAdapted);
      //Alternatively, the adaption can be done using the operators
      //hom_mat3d_translate_local and hom_mat3d_rotate_local
      //as shown in the following two lines
      HOperatorSet.HomMat3dTranslateLocal(hv_HomMat3D, 0, 3.2, 0, out hv_HomMat3DTranslate);
      HOperatorSet.HomMat3dRotateLocal(hv_HomMat3DTranslate, (new HTuple(-14)).TupleRad()
          , "x", out hv_HomMat3DAdapted);
      HOperatorSet.HomMat3dToPose(hv_HomMat3DAdapted, out hv_PoseAdapted);
      //Transform the XLD contour to the WCS using the adapted pose
      ho_ContoursTrans.Dispose();
      HOperatorSet.ContourToWorldPlaneXld(ho_Lines, out ho_ContoursTrans, hv_CamParam, 
          hv_PoseAdapted, 1);
      HOperatorSet.GetContourXld(ho_ContoursTrans, out hv_YOfContour, out hv_XOfContour);
      HOperatorSet.TupleMean(hv_XOfContour, out hv_MeterReading);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Lines, HDevWindowStack.GetActive());
      }
      disp_message(hv_WindowHandle, ("Meter reading: "+(hv_MeterReading.TupleString(
          ".3f")))+"mm", "window", 400, 180, "green", "false");
      disp_continue_message(hv_WindowHandle, "black", "true");
      // stop(...); only in hdevelop
      // dev_close_inspect_ctrl(...); only in hdevelop
      // dev_close_inspect_ctrl(...); only in hdevelop
      //Now, transform the whole image
      hv_WidthMappedImage = 652;
      hv_HeightMappedImage = 494;
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //First, determine the scale for the mapping
      //(here, the scale is determined such that in the
      //surroundings of the points P0 and P1, the image scale of the
      //mapped image is similar to the image scale of the original image)
      HOperatorSet.DistancePp(hv_X.TupleSelect(0), hv_Y.TupleSelect(0), hv_X.TupleSelect(
          1), hv_Y.TupleSelect(1), out hv_DistP0P1WCS);
      HOperatorSet.DistancePp(hv_RCoord.TupleSelect(0), hv_CCoord.TupleSelect(0), 
          hv_RCoord.TupleSelect(1), hv_CCoord.TupleSelect(1), out hv_DistP0P1PCS);
      hv_Scale = hv_DistP0P1WCS/hv_DistP0P1PCS;
      //Then, determine the parameter settings for set_origin_pose such
      //that the point given via get_mbutton will be in the center of the
      //mapped image
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      disp_message(hv_WindowHandle, "Define the center of the mapped image", "window", 
          12, 12, "red", "false");
      HOperatorSet.GetMbutton(hv_WindowHandle, out hv_CenterRow, out hv_CenterColumn, 
          out hv_Button1);
      HOperatorSet.ImagePointsToWorldPlane(hv_CamParam, hv_FinalPose, hv_CenterRow, 
          hv_CenterColumn, 1, out hv_CenterX, out hv_CenterY);
      HOperatorSet.SetOriginPose(hv_FinalPose, hv_CenterX-((hv_Scale*hv_WidthMappedImage)/2.0), 
          hv_CenterY-((hv_Scale*hv_HeightMappedImage)/2.0), 0, out hv_PoseNewOrigin);
      ho_Map.Dispose();
      HOperatorSet.GenImageToWorldPlaneMap(out ho_Map, hv_CamParam, hv_PoseNewOrigin, 
          652, 494, hv_WidthMappedImage, hv_HeightMappedImage, hv_Scale, "bilinear");
      ho_ImageMapped.Dispose();
      HOperatorSet.MapImage(ho_Image, ho_Map, out ho_ImageMapped);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ImageMapped, HDevWindowStack.GetActive());
      }
      //In the case that only one image has to be mapped, the operator
      //image_to_world_plane can be used instead of the operators
      //gen_image_to_world_plane_map and map_image.
      ho_ImageMapped.Dispose();
      HOperatorSet.ImageToWorldPlane(ho_Image, out ho_ImageMapped, hv_CamParam, hv_PoseNewOrigin, 
          hv_WidthMappedImage, hv_HeightMappedImage, hv_Scale, "bilinear");
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_Caltab.Dispose();
      ho_ROI.Dispose();
      ho_ImageReduced.Dispose();
      ho_Lines.Dispose();
      ho_ContoursTrans.Dispose();
      ho_Map.Dispose();
      ho_ImageMapped.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Image.Dispose();
    ho_Caltab.Dispose();
    ho_ROI.Dispose();
    ho_ImageReduced.Dispose();
    ho_Lines.Dispose();
    ho_ContoursTrans.Dispose();
    ho_Map.Dispose();
    ho_ImageMapped.Dispose();

  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

